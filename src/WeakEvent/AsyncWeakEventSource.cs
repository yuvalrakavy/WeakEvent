using System;
using System.Threading.Tasks;
using System.Linq;
using static WeakEvent.WeakEventSourceHelper;

namespace WeakEvent {
    /// <summary>
    /// Represents the method that will handle an event asynchronously when the event provides data.
    /// </summary>
    /// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
    /// <param name="sender">The source of the event.</param>
    /// <param name="e">An object that contains the event data.</param>
    /// <returns></returns>
    public delegate Task AsyncEventHandler<TEventArgs>(object sender, TEventArgs e);

    /// <summary>
    /// An async event with weak subscription, i.e. it won't keep handlers from being garbage collected.
    /// </summary>
    /// <typeparam name="TEventArgs">The type of the event data generated by the event.</typeparam>
    public class AsyncWeakEventSource<TEventArgs> {
        internal DelegateCollection? _handlers;

        /// <summary>
        /// Raises the event by invoking each handler that hasn't been garbage collected.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="args">An object that contains the event data.</param>
        /// <remarks>The handlers are invoked one after the other, in the order they were subscribed in.
        /// Each handler is awaited before invoking the next one.</remarks>
        public async Task RaiseAsync(object? sender, TEventArgs args) {
            var validHandlers = GetValidHandlers(_handlers);
            foreach(var handler in validHandlers) {
                await handler.Invoke(sender, args).ConfigureAwait(false);
            }
        }

        /// <summary>
        /// Raises the event by invoking each handler that hasn't been garbage collected. Exceptions thrown by
        /// individual handlers are passed to the specified <c>exceptionHandler</c> to decide what to do with them.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="args">An object that contains the event data.</param>
        /// <param name="exceptionHandler">A delegate that handles exceptions thrown by individual handlers.
        /// Return <c>true</c> to indicate that the exception was handled.</param>
        /// <remarks>The handlers are invoked one after the other, in the order they were subscribed in.
        /// Each handler is awaited before invoking the next one.</remarks>
        public async Task RaiseAsync(object? sender, TEventArgs args, Func<Exception, bool> exceptionHandler) {
            if(exceptionHandler is null) throw new ArgumentNullException(nameof(exceptionHandler));
            var validHandlers = GetValidHandlers(_handlers);
            foreach(var handler in validHandlers) {
                try {
                    await handler.Invoke(sender, args).ConfigureAwait(false);
                }
                catch(Exception ex) when(exceptionHandler(ex)) {
                }
            }
        }

        /// <summary>
        /// Raises the event by invoking each handler that hasn't been garbage collected. Exceptions thrown by
        /// individual handlers are passed to the specified <c>exceptionHandler</c> to decide what to do with them.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="args">An object that contains the event data.</param>
        /// <param name="exceptionHandler">A delegate that handles exceptions thrown by individual handlers.
        /// Return <c>true</c> to indicate that the exception was handled.</param>
        /// <remarks>The handlers are invoked one after the other, in the order they were subscribed in.
        /// Each handler is awaited before invoking the next one.</remarks>
        public async Task RaiseAsync(object? sender, TEventArgs args, Func<Exception, Task<bool>> exceptionHandler) {
            if(exceptionHandler is null) throw new ArgumentNullException(nameof(exceptionHandler));
            var validHandlers = GetValidHandlers(_handlers);
            foreach(var handler in validHandlers) {
                try {
                    await handler.Invoke(sender, args).ConfigureAwait(false);
                }
                catch(Exception ex) {
                    if(!await exceptionHandler(ex).ConfigureAwait(false)) {
                        throw;
                    }
                }
            }
        }

        /// <summary>
        /// Adds an event handler.
        /// </summary>
        /// <param name="handler">The handler to subscribe.</param>
        /// <remarks>Only a weak reference to the handler's <c>Target</c> is kept, so that it can be garbage collected.</remarks>
        public void Subscribe(AsyncEventHandler<TEventArgs> handler) {
            Subscribe(null, handler);
        }

        /// <summary>
        /// Adds an event handler, specifying a lifetime object.
        /// </summary>
        /// <param name="lifetimeObject">An object that keeps the handler alive as long as it's alive.</param>
        /// <param name="handler">The handler to subscribe.</param>
        /// <remarks>Only a weak reference to the handler's <c>Target</c> is kept, so that it can be garbage collected.
        /// However, as long as the <c>lifetime</c> object is alive, the handler will be kept alive. This is useful for
        /// subscribing with anonymous methods (e.g. lambda expressions).</remarks>
        public void Subscribe(object? lifetimeObject, AsyncEventHandler<TEventArgs> handler) {
            Subscribe<DelegateCollection, OpenEventHandler, StrongHandler>(lifetimeObject, ref _handlers, handler);
        }

        /// <summary>
        /// Removes an event handler.
        /// </summary>
        /// <param name="handler">The handler to unsubscribe.</param>
        /// <remarks>The behavior is the same as that of <see cref="Delegate.Remove(Delegate, Delegate)"/>. Only the last instance
        /// of the handler's invocation list is removed. If the exact invocation list is not found, nothing is removed.</remarks>
        public void Unsubscribe(AsyncEventHandler<TEventArgs> handler) {
            Unsubscribe<OpenEventHandler, StrongHandler>(_handlers, handler);
        }

        /// <summary>
        /// Removes an event handler that was subscribed with a lifetime object.
        /// </summary>
        /// <param name="lifetimeObject">The lifetime object that was associated with the handler.</param>
        /// <param name="handler">The handler to unsubscribe.</param>
        /// <remarks>The behavior is the same as that of <see cref="Delegate.Remove(Delegate, Delegate)"/>. Only the last instance
        /// of the handler's invocation list is removed. If the exact invocation list is not found, nothing is removed.</remarks>
        [Obsolete("This method is obsolete and will be removed in a future version. Use the Unsubscribe overload that doesn't take a lifetime object instead.")]
        public void Unsubscribe(object? lifetimeObject, AsyncEventHandler<TEventArgs> handler) {
            Unsubscribe(handler);
        }

        /// <summary>
        ///  Return true if this event has any valid handlers.
        /// </summary>
        public bool HasSubscribers => GetValidHandlers(_handlers).Any();

        /// <Summary>
        ///  Get valid handlers count
        /// </Summary>
        public int SubscriberCount => GetValidHandlers(_handlers).Count();

        internal delegate Task OpenEventHandler(object? target, object? sender, TEventArgs e);

        internal struct StrongHandler {
            private readonly object? _target;
            private readonly OpenEventHandler _openHandler;

            public StrongHandler(object? target, OpenEventHandler openHandler) {
                _openHandler = openHandler;
                _target = target;
            }

            public Task Invoke(object? sender, TEventArgs e) {
                return _openHandler(_target, sender, e);
            }
        }

        internal class DelegateCollection : DelegateCollectionBase<OpenEventHandler, StrongHandler> {
            public DelegateCollection()
                : base((target, openHandler) => new StrongHandler(target, openHandler)) {
            }
        }
    }
}
